# tximport for downstream DEseq analysis

source("https://bioconductor.org/biocLite.R")
# biocLite("tximport")
# vignette("tximport")
# biocLite("tibble")
# biocLite("DESeq2")
# biocLite("digest")
library("tximport")
library("readr")
library("DESeq2")
# citation("tximport") 
# 
# ?tximport()
# 
# biocLite("DESeq2")
vignette("DESeq2")

# We begin with quantification files generated by the Salmon software
direc <- dir("~/UCSB/Sequencing Analysis/2018 mRNAseq-TC/Galaxy Output/Salmon/Transcripts/")

# Next, we create a named vector pointing to the quantification files. We will create
# a vector of filenames first by reading in a table that contains the sample IDs, and then combining this with dir and "quant.sf"
######?????#### RNAseq.samples <- read.table(file.path(direc, "samples.txt"), header = TRUE)
### vignette shows how to query a particular file structure to retrieve only desired out.files
# I don't need to do this since I manally downloaded and named the files already (I think)
#file.path(direc, "salmon", 1:10, "quant.sf")

files <- file.path("~/UCSB/Sequencing Analysis/2018 mRNAseq-TC/Galaxy Output/Salmon/Transcripts", direc)

names(files) <- paste0("sample_",1:32)
files
all(file.exists(files))

# Transcripts need to be associated with gene IDs for gene-level summarization. 
# For Salmon, Sailfish, and kallisto the files only provide the transcript ID.
# We first make a data.frame called tx2gene with two columns: 1) transcript ID and 2) gene ID.
# The column names do not matter but this column order must be used.
# The transcript ID must be the same one used in the abundance files.

# biocLite("AnnotationDbi")
# browseVignettes("AnnotationDbi")

# I used Galaxy to Extract Features (transcripts) from the WS263 gtf file, then downloaded to PC, opened in Excel, separated out comment lines
# into columns, and arranged transcript IDs and WEGene IDs.

tx2gene <- read.delim("~/UCSB/Sequencing Analysis/2018 mRNAseq-TC/Reference Data WS263/transcript2genes.txt", header = F, sep = "\t")
head(tx2gene)
tail(tx2gene)

# The tximport package has a single function for importing transcript-level estimates.
# The type argument is used to specify what software was used for estimation (“kallisto”, “salmon”, “sailfish”, and “rsem” are implemented).
# A simple list with matrices, “abundance”, “counts”, and “length”, is returned,
# where the transcript level information is summarized to the gene-level.
# The “length” matrix can be used to generate an offset matrix for downstream gene-level differential analysis of count matrices, as shown below.


txi <- tximport(files = files, type = "salmon", tx2gene = tx2gene, dropInfReps = TRUE)
names(txi)
head(txi$abundance)
head(txi$counts)
head(txi$length)
txi$countsFromAbundance

# Creating a DESeqDataSet for use with DESeq2 (Love, Huber, and Anders 2014):
  
# library(DESeq2)
#### The user should make sure the rownames of sampleTable align with the colnames of txi$counts, if there are colnames.
# The best practice is to read sampleTable from a CSV file, and to construct files from a column of sampleTable, 
# as was shown in the tximport examples above.

# sampleTable <- data.frame(condition = factor(rep(c("A", "B"), each = 3)))
# rownames(sampleTable) <- head(colnames(txi$counts), 6)

sampleTable <- read.csv(file = "~/UCSB/Sequencing Analysis/2018 mRNAseq-TC/SampleTable.csv")
sampleTable <- data.frame(factor(sampleTable$Strain),factor(sampleTable$HrsPHS))
colnames(sampleTable) <- c("Strain","HrsPHS")
rownames(sampleTable) <- colnames(txi$counts)
sampleTable
str(sampleTable)

###############################################################
##### Creating a DESeq Data Set for analysis with DESeq2! #####
###############################################################
dds <- DESeqDataSetFromTximport(txi = txi, colData = sampleTable, design = ~ Strain + HrsPHS + Strain:HrsPHS)

#### Moving on to Bioconductor Workflow: http://bioconductor.org/help/workflows/rnaseqGene/ 
#5 Exploratory analysis and visualization
# 5.1 Pre-filtering the dataset
# Our count matrix with our DESeqDataSet contains many rows with only zeros, and additionally many rows with
# only a few fragments total. In order to reduce the size of the object, and to increase the speed of our functions,
# we can remove the rows that have no or nearly no information about the amount of gene expression. Here we apply 
# the most minimal filtering rule: removing rows of the DESeqDataSet that have no counts, or only a single count
# across all samples. Additional weighting/filtering to improve power is applied at a later step in the workflow.
nrow(dds)  #20094
str(dds)
head(dds)

dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)  #20062 (only removed 32 genes...)

### Packages/Libraries needed for meanSdPlot
# biocLite("vsn")
library("vsn")
# biocLite("hexbin")
library("hexbin")

meanSdPlot(txi$abundance, ranks = T)  #shows how more highly expressed genes have much greater absolute variability in expression
meanSdPlot(txi$counts, ranks = T)

meanSdPlot(txi$abundance, ranks = F)
meanSdPlot(txi$length, ranks = F)
meanSdPlot(txi$length, ranks = T)


# DESeq2 offers two transformations for count data that stabilize the variance across the mean: the regularized-logarithm
# transformation or rlog (Love, Huber, and Anders 2014), and the variance stabilizing transformation (VST) for negative binomial
# data with a dispersion-mean trend (Anders and Huber 2010), implemented in the vst function.
# The rlog-transformed or VST data then becomes approximately homoskedastic, and can be used directly for computing
# distances between samples, making PCA plots, or as input to downstream methods which perform best with homoskedastic data.


# The function rlog returns an object based on the SummarizedExperiment class that contains the rlog-transformed values in its assay slot.
# biocLite("tibble")
# library("tibble")
rld <- rlog(dds, blind = FALSE)
head(assay(rld), 3)

# The function vst returns a similar object:
vsd <- vst(dds, blind = FALSE)
head(assay(vsd), 3)


# To show the effect of the transformation, in the figure below we plot the first sample against the second,
# first simply using the log2 function (after adding 1, to avoid taking the log of zero), and then using the
# rlog- and VST-transformed values. For the log2 approach, we need to first estimate size factors to account
# for sequencing depth, and then specify normalized=TRUE. Sequencing depth correction is done automatically for the rlog and the vst.
# biocLite("dplyr")
library("dplyr")
library("ggplot2")

dds <- estimateSizeFactors(dds)

df <- bind_rows(
  as_data_frame(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
    mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"))

colnames(df)[1:2] <- c("x", "y")  

######### Scatterplot of transformed counts from two samples.
# Shown are scatterplots using the log2 transform of normalized counts (left),
# using the rlog (middle), and using the VST (right). While the rlog is on roughly the same scale as the log2 counts, the VST has
# a upward shift for the smaller values. It is the differences between samples (deviation from y=x in these scatterplots) which
# will contribute to the distance calculations and the PCA plot.
ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation)  


######################################################
# 5.3 Sample distances
# We use the R function dist to calculate the Euclidean distance between samples. To ensure we have a roughly equal
# contribution from all genes, we use it on the rlog-transformed data. We need to transpose the matrix of values using t,
# because the dist function expects the different samples to be rows of its argument, and different dimensions (here, genes) to be columns.
sampleDists <- dist(t(assay(rld)))
sampleDists
# biocLite("pheatmap")
library("pheatmap")
library("RColorBrewer")

sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( rld$Strain, rld$HrsPHS, sep = " - " )
colnames(sampleDistMatrix) <- paste( rld$Strain, rld$HrsPHS, sep = " - " )
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
# Heatmap of sample-to-sample distances using the rlog-transformed values.
pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors)


# 5.4 PCA plot
plotPCA(rld, intgroup = c("Strain", "HrsPHS"))


# Custom PCA plot from scratch using ggplot2
library("ggplot2")
pcaData <- plotPCA(rld, intgroup = c( "Strain", "HrsPHS"), returnData = TRUE)
pcaData

percentVar <- round(100 * attr(pcaData, "percentVar"))
attributes(pcaData) #see all the attributes for an object
attr(pcaData, "names") #testing the attribute retrieve function

ggplot(pcaData, aes(x = PC1, y = PC2, color = HrsPHS, shape = Strain)) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed()


# Dispersion Plot
plotDispEsts(ddsTC)

row.names(resTC)[which(resTC$padj<10^-75)]

row.names(resTC)[which.max(resTC$padj)] #WBGene00001641

# 6.1 Running the differential expression pipeline
# As we have already specified an experimental design when we created the DESeqDataSet, we can run the differential
# expression pipeline on the raw counts with a single call to the function DESeq:

########################################  
# Fresh construction of DESeq data set #
########################################
dds <- DESeqDataSetFromTximport(txi = txi, colData = sampleTable, design = ~ Strain + HrsPHS + Strain:HrsPHS)
design(dds)

### Differential expression pipeline
# dds <- DESeq(dds)

summary(dds)
head(dds)
str(dds)
attributes(dds)
?DESeq

colData(dds)
mcols(dds)
dds

######################################
##### 10 Time course experiments #####
######################################
# The following chunk of code performs a likelihood ratio test, where we remove the strain-specific differences over time.
# Genes with small p values from this test are those which at one or more time points after time 0 showed a strain-specific effect.
# Note therefore that this will not give small p values to genes that moved up or down over time in the same way in both strains.

# Running the differential expression analysis using the "Likelihood Ratio Test"
ddsTC <- DESeq(dds, test="LRT", reduced = ~ Strain + HrsPHS)
resTC <- results(ddsTC)
# resTC$symbol <- mcols(ddsTC)$symbol
head(resTC[order(resTC$padj),], 4)
ddsTC$HrsPHS
mcols(ddsTC)

# We can plot the counts for the groups over time using ggplot2, for the gene with the smallest adjusted p value,
# testing for condition-dependent time profile and accounting for differences at time 0 (figure below). Keep in mind
# that the interaction terms are the difference between the two groups at a given time after accounting for the difference at time 0.

TCexpnplot <- plotCounts(ddsTC, which.min(resTC$padj), intgroup = c("HrsPHS","Strain"), returnData = TRUE)

rownames(resTC[which.min(resTC$padj),])  #WBGene00007786

# Version 1
ggplot(TCexpnplot, aes(x = as.numeric(HrsPHS), y = count, color = Strain, group = Strain)) + 
  geom_point() + geom_smooth(se = FALSE, method = "loess") + scale_y_log10()
# Version 2
ggplot(TCexpnplot, aes(x = as.numeric(HrsPHS), y = count, color = Strain, group = Strain)) + 
  geom_point() + geom_smooth(se = FALSE, method = "loess") + ggtitle(rownames(resTC[which.min(resTC$padj),]))

?ggplot


# Wald tests for the log2 fold changes at individual time points can be investigated using the test argument to results:
resultsNames(ddsTC)
# [1] "Intercept"               "Strain_JR3642_vs_CL2070" "HrsPHS_3_vs_0"           "HrsPHS_6_vs_0"           "HrsPHS_12_vs_0"         
# [6] "HrsPHS_30_vs_0"          "StrainJR3642.HrsPHS3"    "StrainJR3642.HrsPHS6"    "StrainJR3642.HrsPHS12"   "StrainJR3642.HrsPHS30"  

res3hrPHS <- results(ddsTC, name="StrainJR3642.HrsPHS3", test="Wald")
res3hrPHS[which.min(resTC$padj),]
head(res3hrPHS)


# We can furthermore cluster significant genes by their profiles. We extract a matrix of the
# shrunken log2 fold changes using the coef function:
betas <- coef(ddsTC)
colnames(betas)
head(betas)

# We can now plot the log2 fold changes in a heatmap (figure below).
topGenes <- head(order(resTC$padj),20)
mat <- betas[topGenes, -c(1,2)]
thr <- 6
mat[mat < -thr] <- -thr
mat[mat > thr] <- thr
pheatmap(mat, breaks=seq(from=-thr, to=thr, length=100),
         cluster_col=FALSE)

###############################
##### Heatmap of ALL DEGs #####

# We can now plot the log2 fold changes in a heatmap (figure below).
mat <- betas[, -c(1,2)]
mat <- mat[complete.cases(mat),] #need to remove any rows with NA
summary(mat)

thr <- 5 #threshold level for the range of FC values to plot
mat[mat < -thr] <- -thr
mat[mat > thr] <- thr
summary(mat) #no more NAs, max and min values set
# WARNING: this heatmap takes >10min to plot
pheatmap(mat, breaks=seq(from=-thr, to=thr, length=101),
         cluster_col=FALSE, gaps_col = 4, show_rownames = F)
str(mat)
length(mat[,1]) #20,081 rows/genes

# with kmeans_k clustering
pheatmap(mat, breaks=seq(from=-thr, to=thr, length=101),
         cluster_col=FALSE, gaps_col = 4, show_rownames = F, kmeans_k = 100)

# different k = __
head(mat[,1:8])
pheatmap(mat[,1:8], breaks=seq(from=-thr, to=thr, length=101),
         cluster_col=FALSE, gaps_col = 4, show_rownames = F, kmeans_k = 5)

?kmeans

 





# # 6.2 Building the results table  (see separate R script "DESeqResults.R")
# # Calling results without any arguments will extract the estimated log2 fold changes and p values for the last variable
# # in the design formula. If there are more than 2 levels for this variable, results will extract the results table for
# # a comparison of the last level over the first level. The comparison is printed at the top of the output: dex trt vs untrt.
# 
# res <- results(dds)
# res
# 
# mcols(res, use.names = T) # metadata with the meaning of the columns in results()
# 
# resultsNames(dds) #returns the names of the estimated effects (coefficents) of the model
# 
# res <- results(dds, contrast = c("Strain", "JR3642", "CL2070"))
# res
# summary(res)
# table(res$padj < .1)
# 
# plotMA(res)
# 
# # 6.4 Multiple testing
# # Hence, if we consider a fraction of 10% false positives acceptable, we can consider all genes with
# # an adjusted p value below 10% = 0.1 as significant. How many such genes are there?
#   
# sum(res$padj < 0.1, na.rm=TRUE)
# ## [1] 1614
# # We subset the results table to these genes and then sort it by the log2 fold change estimate to get the significant genes
# # with the strongest down-regulation:
# resSig <- subset(res, padj < 0.1)
# head(resSig[ order(resSig$log2FoldChange), ])
# # …and with the strongest up-regulation:
# head(resSig[ order(resSig$log2FoldChange, decreasing = TRUE), ])
# # and greatest significance
# head(resSig[ order(resSig$padj),])